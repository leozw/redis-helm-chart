CHART NAME: {{ .Chart.Name }}
CHART VERSION: {{ .Chart.Version }}
APP VERSION: {{ .Chart.AppVersion }}

** Redis has been deployed successfully! **

Architecture: {{ .Values.architecture }}

{{- if .Values.auth.enabled }}

1. Get your Redis password:
   
   export REDIS_PASSWORD=$(kubectl get secret {{ include "redis.secretName" . }} -n {{ .Release.Namespace }} -o jsonpath="{.data.redis-password}" | base64 -d)
   echo $REDIS_PASSWORD
{{- else }}

1. Redis has been deployed WITHOUT authentication.
   WARNING: This is not recommended for production environments!
{{- end }}

2. Connect to Redis:

{{- if eq .Values.architecture "standalone" }}

   {{- if contains "NodePort" .Values.service.type }}
   Get the Redis port:
   export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "redis.serviceName" . }})
   export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
   
   Connect:
   redis-cli -h $NODE_IP -p $NODE_PORT {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}

   {{- else if contains "LoadBalancer" .Values.service.type }}
   NOTE: It may take a few minutes for the LoadBalancer IP to be available.
   You can watch the status by running:
   kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "redis.serviceName" . }}
   
   Get the Redis IP:
   export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "redis.serviceName" . }} --template "{{ "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}" }}")
   
   Connect:
   redis-cli -h $SERVICE_IP -p {{ .Values.service.port }} {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}

   {{- else if contains "ClusterIP" .Values.service.type }}
   Port forward to access Redis:
   kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "redis.serviceName" . }} 6379:{{ .Values.service.port }}
   
   In another terminal, connect:
   redis-cli -h 127.0.0.1 -p 6379 {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}
   {{- end }}

{{- else if eq .Values.architecture "replication" }}

   Master endpoint: {{ include "redis.masterServiceName" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.service.port }}
   Replica endpoint: {{ include "redis.replicaServiceName" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.service.port }}

   {{- if contains "NodePort" .Values.service.type }}
   Get the Redis Master port:
   export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "redis.masterServiceName" . }})
   export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
   
   Connect to master:
   redis-cli -h $NODE_IP -p $NODE_PORT {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}

   {{- else if contains "LoadBalancer" .Values.service.type }}
   NOTE: It may take a few minutes for the LoadBalancer IP to be available.
   You can watch the status by running:
   kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "redis.masterServiceName" . }}
   
   Get the Redis Master IP:
   export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "redis.masterServiceName" . }} --template "{{ "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}" }}")
   
   Connect to master:
   redis-cli -h $SERVICE_IP -p {{ .Values.service.port }} {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}

   {{- else if contains "ClusterIP" .Values.service.type }}
   Port forward to access Redis master:
   kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "redis.masterServiceName" . }} 6379:{{ .Values.service.port }}
   
   In another terminal, connect:
   redis-cli -h 127.0.0.1 -p 6379 {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}
   {{- end }}

{{- end }}

3. Connect from within the cluster:
   
   {{- if eq .Values.architecture "standalone" }}
   redis-cli -h {{ include "redis.serviceName" . }}.{{ .Release.Namespace }}.svc.cluster.local -p {{ .Values.service.port }} {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}
   {{- else }}
   # Connect to master (read-write):
   redis-cli -h {{ include "redis.masterServiceName" . }}.{{ .Release.Namespace }}.svc.cluster.local -p {{ .Values.service.port }} {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}
   
   # Connect to replicas (read-only):
   redis-cli -h {{ include "redis.replicaServiceName" . }}.{{ .Release.Namespace }}.svc.cluster.local -p {{ .Values.service.port }} {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}
   {{- end }}

4. Create a Redis client pod:
   kubectl run -it --rm --image=redis:7.2.5-alpine --restart=Never redis-client \
     -- redis-cli -h {{ include "redis.serviceName" . }}.{{ .Release.Namespace }}.svc.cluster.local {{ if .Values.auth.enabled }}-a $REDIS_PASSWORD{{ end }}

{{- if .Values.metrics.enabled }}

5. Metrics are exposed on port {{ .Values.metrics.port }}:
   kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "redis.fullname" . }}-metrics 9121:{{ .Values.metrics.port }}
   
   Access metrics at: http://localhost:9121/metrics
{{- end }}

{{- if .Values.persistence.enabled }}

6. Persistence is ENABLED. Data will be preserved across pod restarts.
   {{- if .Values.statefulset }}
   Storage: {{ (index .Values.persistence.volumeClaimTemplates 0).resources.requests.storage }}
   {{- else }}
   Storage: {{ .Values.persistence.size }}
   {{- end }}
{{- else }}

6. WARNING: Persistence is DISABLED. Data will be lost if the pod is terminated!
{{- end }}

For more information, check:
- Redis documentation: https://redis.io/docs/
- Chart documentation: https://github.com/yourusername/redis-helm-chart